//! A custom error wrapper to unify errors and warnings

use allwhat::ErrorGroup;

pub type Result<T, E = SubparError> = core::result::Result<T, E>;

/// A structure for capturing errors generated by Tyrell
#[derive(Debug)]
pub struct SubparError {
  /// The general error genus
  kind: Kind,

  /// An error message geared toward an end user
  comment: Option<String>,

  context: Option<String>,
}

impl SubparError {
  pub fn new(kind: Kind) -> SubparError {
    SubparError {
      kind,
      comment: None,
      context: None,
    }
  }

  pub fn kind(&self) -> &Kind {
    &self.kind
  }

  pub fn comment(mut self, comment: String) -> SubparError {
    self.comment = Some(comment);
    self
  }

  pub fn context(mut self, context: String) -> SubparError {
    self.context = Some(context);
    self
  }
}

impl std::fmt::Display for SubparError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "{:?}", self)
  }
}

/// The full set of exceptions that can be raised at any step in this process
///
/// This will be used as the "source" of the SubparError error
#[derive(Debug, thiserror::Error)]
pub enum Kind {
  #[error("GenericError")]
  GenericError,

  #[error("A group of errors assembled from a transaction/iteration loop")]
  ErrorList(ErrorGroup),

  #[error("A situation which should return a unique item returned multiple")]
  AmbiguousResult,

  #[error("An invalid parameter was received by the current function")]
  BadValue,

  #[error("Tried to use an item already in use")]
  Busy,

  #[error("An item being used as a key was not unique")]
  DuplicateKey,

  #[error("Internal error converting one type to another")]
  ConversionError,

  #[error("EmptyWorksheet")]
  EmptyWorksheet,

  #[error("IncorrectExcelObject")]
  IncorrectExcelObject,

  #[error("InvalidCellType")]
  InvalidCellType,

  #[error("Problem with the workbook location value")]
  InvalidLocation,

  #[error("InvalidPath")]
  InvalidPath,

  #[error("The current condition is supposed to be impossible")]
  Impossible,

  #[error("FileReadOnly")]
  FileReadOnly,

  #[error("NetworkError")]
  NetworkError,

  #[error("NotFound")]
  NotFound,

  #[error("NotImplemented")]
  NotImplemented,

  #[error("A required value was not set")]
  NullValue,

  #[error("FloatParseError")]
  FloatParseError,
  #[error("ReadOnly")]
  ReadOnly,
  #[error("UnknownColumn")]
  UnknownColumn,
  #[error("UnknownSheet")]
  UnknownSheet,
  #[error("UnexpectedError")]
  UnexpectedError,
  #[error("ExcelError")]
  ExcelError,
  #[error("SheetsError")]
  SheetsError,
  #[error("WorkbookMismatch")]
  WorkbookMismatch,
  #[error("ParsingError")]
  ParsingError,
  #[error("There a problem with locking an object for read/write due to an uncaught error")]
  RwLockError,
  #[error("URL could not be processed")]
  UrlError,

  #[error("An error generated by a CSV reader")]
  CsvError(#[from] ::csv::Error),

  #[error("JSON (de)serializing Error")]
  JsonError(#[from] serde_json::Error),

  #[error("Error converting a string to an integer")]
  ParseIntError(#[from] std::num::ParseIntError),

  #[error("IO Error")]
  Io(#[from] std::io::Error),
}

impl From<ErrorGroup> for Kind {
  fn from(group: ErrorGroup) -> Kind {
    log::warn!("In convert error group to kind");
    Kind::ErrorList(group)
  }
}

impl From<ErrorGroup> for SubparError {
  fn from(group: ErrorGroup) -> SubparError {
    SubparError::new(group.into())
  }
}

pub trait Comment<T, E> {
  fn comment<C>(self, comment: C) -> Result<T, SubparError>
  where
    C: Into<String>;
  fn context<C>(self, ctx: C) -> Result<T, SubparError>
  where
    C: std::fmt::Display + std::fmt::Debug + Sync + Send + 'static;
}

impl<T, E> Comment<T, E> for Result<T, E>
where
  E: Into<SubparError>,
{
  fn comment<C>(self, comment: C) -> Result<T, SubparError>
  where
    C: Into<String>,
  {
    match self {
      Ok(x) => Ok(x),
      Err(err) => {
        // Convert into a fhl error, if possible
        let mut err: SubparError = err.into();
        err.comment = Some(comment.into());
        Err(err)
      }
    }
  }

  fn context<C>(self, ctx: C) -> Result<T, SubparError>
  where
    C: std::fmt::Display + std::fmt::Debug + Sync + Send + 'static,
  {
    match self {
      Ok(x) => Ok(x),
      Err(err) => {
        // Convert into a fhl error, if possible
        let mut err: SubparError = err.into();
        err.context = Some(format!("{:#?}", ctx));
        Err(err)
      }
    }
  }
}

/// Simple macro to create an FHL error
#[macro_export]
macro_rules! err {
  (@comment $($comment:expr),+) => {
    format!($($comment),+)
  };
  (@comment $comment:expr) => {
    $comment.to_string()
  };
  ($kind:ident $(, $($comment:expr),+)?) => {
    SubparError::new(Kind::$kind)
      $(.comment(err!(@comment $($comment),+)))?
  };
}

#[macro_export]
macro_rules! err_into {
  (@comment $($comment:expr),+) => {
    format!($($comment),+)
  };
  (@comment $comment:expr) => {
    $comment.to_string()
  };
  ($res:expr $(, $($comment:expr),+)?) => {
    match $res {
      Ok(x) => Ok(x),
      Err(err) =>
        Err(SubparError::new(err.into()))
          $(.comment::<String>(err_into!(@comment $($comment),+).into()))?,
    }
  };
}

/// Adds a comment/type to the try (?) functionality
#[macro_export]
macro_rules! unwrap {
  (@comment $($comment:expr),+) => {
    format!($($comment),+)
  };
  (@comment $comment:expr) => {
    $comment.to_string()
  };
  ($res:expr $(, $($comment:expr),+)?) => {
    match $res {
      Ok(x) => x,
      Err(err) =>
        Err(SubparError::new(err.into()))
          $(.comment::<String>(unwrap!(@comment $($comment),+)))??,
    }
  };
}
